@startuml
enum CheckForContentUpdateRestrictionsOptions {
    ListUpdatedAssetsWithRestrictions= 0,
    FailBuild= 1,
    Disabled= 2,
}
struct AssetState {
    + Equals(other:AssetState) : bool
}
class CachedAssetState {
    + groupGuid : string
    + bundleFileId : string
    + data : object
    + Equals(other:CachedAssetState) : bool
}
class CachedBundleState {
    + bundleFileId : string
    + data : object
}
class AddressablesContentState {
    + playerVersion : string
    + editorVersion : string
    + remoteCatalogLoadPath : string
}
struct ContentUpdateUsageData {
    + ContentUpdateInterruptMessage : string
    + UsingCCD : bool
}
struct ContentUpdateBuildData {
    + Error : string
    + BuildDuration : double
}
class ContentUpdateScript <<static>> {
    + {static} PreviousContentStateFileCachePath : string <<get>> <<set>>
    + {static} SaveContentState(path:string, entries:List<AddressableAssetEntry>, dependencyData:IDependencyData, playerVersion:string, remoteCatalogPath:string) : bool
    + {static} SaveContentState(locations:List<ContentCatalogDataEntry>, path:string, entries:List<AddressableAssetEntry>, dependencyData:IDependencyData, playerVersion:string, remoteCatalogPath:string) : bool
    + {static} SaveContentState(locations:List<ContentCatalogDataEntry>, path:string, entries:List<AddressableAssetEntry>, dependencyData:IDependencyData, playerVersion:string, remoteCatalogPath:string, carryOverCacheState:List<CachedAssetState>) : bool
    + {static} SaveContentState(locations:List<ContentCatalogDataEntry>, guidToCatalogLocation:Dictionary<GUID, List<ContentCatalogDataEntry>>, path:string, entries:List<AddressableAssetEntry>, dependencyData:IDependencyData, playerVersion:string, remoteCatalogPath:string, carryOverCacheState:List<CachedAssetState>) : bool
    + {static} GetContentStateDataPath(browse:bool) : string
    + {static} GetContentStateDataPath(browse:bool, settings:AddressableAssetSettings) : string
    + {static} LoadContentState(contentStateDataPath:string) : AddressablesContentState
    + {static} BuildContentUpdate(settings:AddressableAssetSettings, contentStateDataPath:string) : AddressablesPlayerBuildResult
    + {static} GatherModifiedEntries(settings:AddressableAssetSettings, cacheDataPath:string) : List<AddressableAssetEntry>
    + {static} GatherModifiedEntriesWithDependencies(settings:AddressableAssetSettings, cachePath:string) : Dictionary<AddressableAssetEntry, List<AddressableAssetEntry>>
    + {static} CreateContentUpdateGroup(settings:AddressableAssetSettings, items:List<AddressableAssetEntry>, groupName:string) : void
}
class "IEquatable`1"<T> {
}
struct ContentUpdateContext {
}
class "Func`2"<T1,T2> {
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
"IEquatable`1" "<AssetState>" <|-- AssetState
AssetState --> "guid" GUID
AssetState --> "hash" Hash128
"IEquatable`1" "<CachedAssetState>" <|-- CachedAssetState
CachedAssetState --> "asset" AssetState
ContentUpdateScript o-> "GroupFilterFunc<AddressableAssetGroup,bool>" "Func`2"
ContentUpdateScript +-- ContentUpdateContext
ContentUpdateContext --> "GuidToPreviousAssetStateMap<string,CachedAssetState>" "Dictionary`2"
ContentUpdateContext --> "IdToCatalogDataEntryMap<string,ContentCatalogDataEntry>" "Dictionary`2"
ContentUpdateContext --> "BundleToInternalBundleIdMap<string,string>" "Dictionary`2"
ContentUpdateContext --> "WriteData" IBundleWriteData
ContentUpdateContext --> "ContentState" AddressablesContentState
ContentUpdateContext --> "Registry" FileRegistry
ContentUpdateContext --> "PreviousAssetStateCarryOver<CachedAssetState>" "List`1"
@enduml
